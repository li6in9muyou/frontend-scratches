<!doctype html>
<html lang="zh" data-theme="dark">
  <head>
    <meta charset="UTF-8" />
    <title>无穷滚动</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        background-color: black;
        color: white;
      }

      main {
        height: 654px;
        border: solid 4px crimson;
        overflow-y: auto;
      }

      .content {
        height: 269px;
        margin: 6px;
        text-align: center;
        background-color: mediumvioletred;
        border: solid 2px white;
        font-size: 90px;
      }
    </style>
  </head>
  <body>
    <main></main>
  </body>
  <script src="js/jquery.js"></script>
  <script>
    function resolveAfter(milliseconds, result) {
      return new Promise((resolve) =>
        setTimeout(() => resolve(result), milliseconds),
      );
    }

    class WaitGroup {
      constructor(init = 0) {
        this.current = init;
        this.allDone = null;
        this.block = new Promise((resolve) => (this.allDone = resolve));
      }
      done() {
        this.current -= 1;
        if (this.current <= 0) {
          this.allDone();
        }
      }
      add(cnt = 1) {
        this.current += cnt;
      }
      wait() {
        return this.block;
      }
    }

    function* genNumbers(start, cnt, step = 1) {
      for (let i = 0; i < cnt; i++) {
        yield start + step * i;
      }
    }
  </script>
  <script>
    $(document).on("scroll wheel", (e) => {
      console.log("document event", e.type, e);
    });
  </script>
  <script type="module">
    const $list = $("main");

    const infiniteScrollEffect = new (function (list, getItem, options) {
      this.MAX_ITEM_COUNT = options?.maxLen ?? 10;
      this.INIT_ITEM_COUNT = options?.initLen ?? 6;
      this.PRELOAD_ITEM_COUNT = options?.preload ?? 3;
      this.getLoading =
        options?.getLoading ??
        (() =>
          $("<div>loading</div>").css({
            "box-sizing": "border-box",
            height: "269px",
            margin: "6px",
            "text-align": "center",
            "background-color": "dimgray",
            border: "solid 2px white",
            "font-size": " 90px",
          }));
      this.LOADING_PLACEHOLDER_H = 269 + 6;
      this.list = list;
      this.getItem = getItem;
      this.keyFront = 0;
      this.keyBack = NaN;
      this.isLoading = false;
      this.obFront = new IntersectionObserver(
        (entries) => {
          console.assert(
            entries.length === 1,
            "multiple observation targets in this.obFront",
          );
          const front = entries[0];
          console.log(
            "this.obFront:" + $(front.target).text(),
            front.intersectionRatio,
          );
          if (front.intersectionRatio > 0.75 && !this.isLoading) {
            this.addFrontManyItems(this.PRELOAD_ITEM_COUNT);
          }
        },
        {
          root: this.list[0] ?? this.list,
          rootMargin: "0px",
          threshold: [0.75],
        },
      );
      this.obBack = new IntersectionObserver(
        (entries) => {
          console.assert(
            entries.length === 1,
            "multiple observation targets in this.obBack",
          );
          const back = entries[0];
          console.log(
            "this.obBack:" + $(back.target).text(),
            back.intersectionRatio,
          );
          if (back.intersectionRatio > 0.75 && !this.isLoading) {
            this.addBackManyItems(this.PRELOAD_ITEM_COUNT);
          }
        },
        {
          root: this.list[0] ?? this.list,
          rootMargin: "0px",
          threshold: [0.75],
        },
      );
      this.getExcessiveItemCnt = () =>
        this.keyBack - this.keyFront - this.MAX_ITEM_COUNT + 1;

      this.__helperRemoveManyItems = (cnt, getNextKey) => {
        this.list.children("[data-ifs-key]").each((_, item) => {
          this.obFront.unobserve(item);
          this.obBack.unobserve(item);
        });
        for (let i = 0; i < cnt; i++) {
          const key = getNextKey();
          this.list.children(`[data-ifs-key='${key}']`).remove();
        }
        const items = this.list.children("[data-ifs-key]");
        this.obFront.observe(items.eq(0)[0]);
        this.obBack.observe(items.eq(-1)[0]);
      };

      this.__helperAddManyItems = (cnt, getNextKey, listModifier) => {
        this.isLoading = true;
        const wg = new WaitGroup();
        for (let i = 0; i < cnt; i++) {
          wg.add();
          const key = getNextKey();
          const $loading = this.getLoading(key);
          this.getItem(key)
            .then(($item) => {
              wg.done();
              $item.attr("data-ifs-key", key);
              return $item;
            })
            .then(($item) => {
              $item.insertAfter($loading);
              $loading.remove();
            });
          listModifier($loading);
        }
        return wg
          .wait()
          .then(() => (this.isLoading = false))
          .then(() => {
            const items = this.list.children("[data-ifs-key]");
            items.each((_, item) => {
              this.obFront.unobserve(item);
              this.obBack.unobserve(item);
            });
            this.obFront.observe(items.eq(0)[0]);
            this.obBack.observe(items.eq(-1)[0]);
          });
      };

      this.addFrontManyItems = (cnt = this.PRELOAD_ITEM_COUNT) => {
        const wait = this.__helperAddManyItems(
          cnt,
          () => {
            this.keyFront -= 1;
            return this.keyFront;
          },
          this.list.prepend.bind(this.list),
        );
        this.list.scrollTop(
          this.PRELOAD_ITEM_COUNT * this.LOADING_PLACEHOLDER_H,
        );
        return wait.then(() =>
          this.__helperRemoveManyItems(
            this.getExcessiveItemCnt(),
            () => this.keyBack--,
          ),
        );
      };

      this.addBackManyItems = (cnt = this.PRELOAD_ITEM_COUNT) =>
        this.__helperAddManyItems(
          cnt,
          () => {
            if (Number.isNaN(this.keyBack)) {
              this.keyBack = 0;
              return this.keyBack;
            } else {
              this.keyBack++;
            }
            return this.keyBack;
          },
          this.list.append.bind(this.list),
        ).then(() =>
          this.__helperRemoveManyItems(
            this.getExcessiveItemCnt(),
            () => this.keyFront++,
          ),
        );

      this.addBackManyItems(this.INIT_ITEM_COUNT);
    })($list, (key) => {
      const $c = $(`<div class="content">${key}</div>`);
      $c.css("height", Math.round(100 + 200 * Math.random()));
      return resolveAfter(1000 + 1000 * Math.random(), $c);
    });
  </script>
</html>
