<!doctype html>
<html lang="zh" data-theme="dark">
  <head>
    <meta charset="UTF-8" />
    <title>无穷滚动</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        background-color: black;
        color: white;
      }

      main {
        height: 654px;
        border: solid 4px crimson;
        overflow-y: auto;
      }

      .content {
        height: 269px;
        margin: 6px;
        text-align: center;
        background-color: mediumvioletred;
        border: solid 2px white;
        font-size: 90px;
      }
    </style>

    <style>
      .ifs--item__loading {
        box-sizing: border-box;
        height: 269px;
        margin: 6px;
        text-align: center;
        background-color: dimgray;
        border: solid 2px white;
        font-size: 90px;
      }
    </style>
  </head>
  <body>
    <main></main>
  </body>
  <script src="js/jquery.js"></script>
  <script>
    function resolveAfter(milliseconds, result) {
      return new Promise((resolve) =>
        setTimeout(() => resolve(result), milliseconds),
      );
    }

    class WaitGroup {
      constructor(init = 0) {
        this.current = init;
        this.allDone = null;
        this.block = new Promise((resolve) => (this.allDone = resolve));
      }
      done() {
        this.current -= 1;
        if (this.current <= 0) {
          this.allDone();
        }
      }
      add(cnt = 1) {
        this.current += cnt;
      }
      wait() {
        return this.block;
      }
    }

    function* genNumbers(start, cnt, step = 1) {
      for (let i = 0; i < cnt; i++) {
        yield start + step * i;
      }
    }
  </script>
  <script>
    $(document).on("scroll wheel", (e) => {
      console.log("document event", e.type, e);
    });
  </script>
  <script type="module">
    const $list = $("main");

    const infiniteScrollEffect = new (function (viewportH, getItem, list) {
      this.LOADING_PLACEHOLDER_H = 269 + 6;
      this.renderedH = 0;
      this.vpH = viewportH;
      this.list = list;
      this.getItem = getItem;
      this.keyFront = 0;
      this.keyBack = NaN;
      this.isLoading = false;
      this.obFront = new IntersectionObserver(
        (entries) => {
          console.assert(
            entries.length === 1,
            "multiple observation targets in this.obFront",
          );
          const front = entries[0];
          console.log(
            "this.obFront:" + $(front.target).text(),
            front.intersectionRatio,
          );
          if (front.intersectionRatio > 0.75 && !this.isLoading) {
            this.addFrontManyItems(3);
          }
        },
        {
          root: this.list[0] ?? this.list,
          rootMargin: "0px",
          threshold: [0.75],
        },
      );
      this.obBack = new IntersectionObserver(
        (entries) => {
          console.assert(
            entries.length === 1,
            "multiple observation targets in this.obBack",
          );
          const back = entries[0];
          console.log(
            "this.obBack:" + $(back.target).text(),
            back.intersectionRatio,
          );
          if (back.intersectionRatio > 0.75 && !this.isLoading) {
            this.addBackManyItems(3);
          }
        },
        {
          root: this.list[0] ?? this.list,
          rootMargin: "0px",
          threshold: [0.75],
        },
      );

      function createLoadingPlaceholder(getContent) {
        const $b = $("<div class='ifs--item__loading'>loading</div>");
        getContent().then(($item) => {
          $item.insertAfter($b);
          $b.remove();
        });
        return $b;
      }

      this.__helperRemoveManyItems = (cnt, getNextKey) => {
        this.list.children(".content").each((_, item) => {
          this.obFront.unobserve(item);
          this.obBack.unobserve(item);
        });
        for (let i = 0; i < cnt; i++) {
          const key = getNextKey();
          this.list.children(`[data-ifs-key='${key}']`).remove();
        }
        const items = this.list.children(".content");
        this.obFront.observe(items.eq(0)[0]);
        this.obBack.observe(items.eq(-1)[0]);
      };

      this.__helperAddManyItems = (cnt, getNextKey, listModifier) => {
        this.isLoading = true;
        const wg = new WaitGroup();
        for (let i = 0; i < cnt; i++) {
          wg.add();
          const key = getNextKey();
          const $item = createLoadingPlaceholder(() =>
            this.getItem(key).then(($item) => {
              wg.done();
              $item.attr("data-ifs-key", key);
              return $item;
            }),
          );
          listModifier($item);
        }
        return wg
          .wait()
          .then(() => (this.isLoading = false))
          .then(() => {
            const items = this.list.children(".content");
            items.each((_, item) => {
              this.obFront.unobserve(item);
              this.obBack.unobserve(item);
            });
            this.obFront.observe(items.eq(0)[0]);
            this.obBack.observe(items.eq(-1)[0]);
          });
      };

      this.addFrontManyItems = (cnt = 3) => {
        const wait = this.__helperAddManyItems(
          cnt,
          () => {
            this.keyFront -= 1;
            return this.keyFront;
          },
          this.list.prepend.bind(this.list),
        );
        this.list.scrollTop(3 * this.LOADING_PLACEHOLDER_H);
        return wait.then(() =>
          this.__helperRemoveManyItems(
            this.keyBack - this.keyFront - 8,
            () => this.keyBack--,
          ),
        );
      };

      this.addBackManyItems = (cnt = 3) =>
        this.__helperAddManyItems(
          cnt,
          () => {
            if (Number.isNaN(this.keyBack)) {
              this.keyBack = 0;
              return this.keyBack;
            } else {
              this.keyBack++;
            }
            return this.keyBack;
          },
          this.list.append.bind(this.list),
        ).then(() =>
          this.__helperRemoveManyItems(
            this.keyBack - this.keyFront - 8,
            () => this.keyFront++,
          ),
        );

      this.addBackManyItems(6);
    })(
      $list.innerHeight(),
      (key) => {
        const $c = $(`<div class="content">${key}</div>`);
        $c.css("height", Math.round(100 + 200 * Math.random()));
        return resolveAfter(1000 + 1000 * Math.random(), $c);
      },
      $list,
    );
  </script>
</html>
