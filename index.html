<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Scratch</title>
  <link rel="stylesheet/less" type="text/css" href="less/styles.less"/>
  <script src="https://cdn.staticfile.net/less.js/4.2.0/less.js"></script>
</head>

<body>
  <header>
    <i class="btn"><</i>
    <h1>产品签约</h1>
  </header>
  <div class="pull-down--pocket" data-loading="false">
    <span class="pull-down--msg">松手加载更多数据</span>
    <span class="pull-down--msg pull-down--msg__loading">正在加载中</span>
  </div>
  <main class="product-list-wrap">
    <section class="product-list-title">
      <h2>产品名称</h2>
      <h2>产品费率</h2>
    </section>
    <section class="product-list">
      <div class="product">
        <div class="product-id">
          <i class="product-icon" data-icon="images/icon-1.png"></i>
          <span class="product-name">微信支付</span>
        </div>
        <div class="product-rates">0.32%</div>
      </div>
    </section>
  </main>
  <footer>
    <p class="tip">线上产品费率不同，详情请咨询：400-0000-0000</p>
    <p class="notes"><strong>用 reduce 一定要指定初始值</strong>，否则如果数组只有一个元素的话，reducer
      根本不会执行。数组没有元素的话，reducer 不执行是符合预期的。</p>
    <pre class="notes">stateDiagram-v2

  [*] --> armed
  armed --> idle : scrollDown
  idle --> armed : scrollToTop

  armed --> pocketRevealed : pullDown
  pocketRevealed --> armed : cancelPull
  pocketRevealed --> callbackCommitted : pullDownFarEnough
  callbackCommitted --> callbackFired : cancelPull
  callbackFired --> armed : okCallback
  callbackFired --> callbackFailed : failCallback
  callbackFailed --> pocketRevealed : pullDown
  callbackFailed --> armed : pullUp

  note left of pocketRevealed: pocket reads "继续下拉加载更多数据"
  note right of callbackCommitted: pocket reads "松手加载更多数据"
  note right of callbackFailed: pocket reads "加载失败，下拉重试"
  note left of callbackFired: pocket reads "加载中，请稍候"</pre>
  </footer>

  <script src="js/jquery.js"></script>
  <script>
    $("[data-icon]").each(function () {
      const i = $(this);
      i.css({
        "background-image": `url(${i.attr("data-icon")})`,
      });
    });
  </script>

  <script>
    const isPreferDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
    if (isPreferDark) {
      $(":root").attr("data-theme", "dark");
    } else {
      $(":root").attr("data-theme", "light");
    }
  </script>

  <script src="js/draggable.js"></script>
  <script src="js/threading.js"></script>
  <script>
    function useEventEmitter(possibleEvents) {
      const listeners = new Map();

      function addEventListener(type, cb) {
        console.assert(possibleEvents.includes(type),
          `StateMachine only emits: ${possibleEvents.join(", ")}, attempt to listen "${type}" event`);
        if (listeners.has(type)) {
          listeners.get(type).push(cb);
        } else {
          listeners.set(type, [cb]);
        }
      }

      function emit(type, data) {
        listeners.get(type)?.forEach(cb => requestIdleCallback(() => cb({ type, data }), { timeout: 30 }));
      }

      return [emit, addEventListener];
    }

    function cross(a, b, delimiter = ":") {
      const ans = new Set();
      for (const aa of a) {
        for (const bb of b) {
          ans.add(`${aa}${delimiter}${bb}`);
        }
      }
      return Array.from(ans);
    }

    function useStateMachine(config) {
      const state = {
        currentState: config.initialState ?? config.states[0].name,
      };
      const adjacentList = new Map(config.states.map(s => ([s.name, s.transitions])));
      const possibleEvents = cross(["enter", "leave"], config.states.map(s => s.name), ":").concat("*:*");
      const [emit, addEventListener] = useEventEmitter(possibleEvents);

      function send(event) {
        const target = adjacentList.get(state.currentState).find(t => t.on === event)?.target;
        if (target === undefined) {
          console.error(`StateMachine: state ${state.currentState} does not accept event ${event}`);
          return;
        }

        const prevState = state.currentState;
        const data = {
          leaving: prevState,
          entering: target,
          event,
        };
        state.currentState = target;
        emit(`leave:${prevState}`, data);
        emit(`enter:${target}`, data);
        emit(`*:*`, data);
      }

      return [send, () => state.currentState, addEventListener];
    }
  </script>
  <script>
    let loading;
    const $productListWrap = $(".product-list-wrap");
    const $productListItems = $(".product");
    for (let i = 0; i < 8; i++) {
      const $c = $productListItems.eq(0).clone();
      $c.find(".product-rates").text(`0.${i + 1}0%`);
      $c.find(".product-name").text(`很好的产品 ${i + 1}`);
      $productListItems.parent().append($c);
    }
    const $pullDown = $(".pull-down--pocket");
    const pullDownState = {
      shouldLoadAfterRelease: false,
      isLoading: false,
    };

    const bizLogic = new (function (scrollable) {
      const S = {
        armed: "armed",
        idle: "idle",
      };

      const [send, queryState, listenToStateMachine] = useStateMachine({
        initialState: "armed",
        states: [
          {
            name: S.armed,
            transitions: [
              { on: "scrollDown", target: S.idle },
            ],
          },
          {
            name: S.idle,
            transitions: [
              { on: "scrollToTop", target: S.armed },
            ],
          },
        ],
      });

      this.handlers = new Map([
        [
          "drag-start",
          () => {
            if (queryState() === S.idle) {
              return Draggable.cancelToken;
            }
          },
        ],
        [
          "scroll-events",
          (e) => {
            const scrollTop = e.target.scrollTop;
            if (queryState() === S.armed) {
              send("scrollDown");
            }
            if (scrollTop === 0) {
              send("scrollToTop");
            }
          },
        ],
        [
          "log-all-state-machine-events",
          data => console.log("bizLogic: state machine event", data),
        ],
      ]);

      this.getHandler = function (f) {
        if (!this.handlers.has(f)) {
          throw `bizLogic: can not handle ${f}`;
        }
        return this.handlers.get(f);
      };

      this.handle = function (f, ...args) {
        return this.getHandler(f)(...args);
      };

      const $scrollable = $(scrollable);
      $scrollable.on("scrollend", this.getHandler("scroll-events"));
      listenToStateMachine("*:*", this.getHandler("log-all-state-machine-events"));
    })($(".product-list"));

    const d = new Draggable(
      $productListWrap[0],
      bizLogic.getHandler("drag-start"),
      [async () => {
        if (!pullDownState.shouldLoadAfterRelease) {
          $productListWrap
            .css({
              top: 0,
              transition: "top .3s",
            })
            .one("transitionend", () => $productListWrap.css("transition", ""));
          return;
        }
        loading = sleep(2000, "some more list items");
        $productListWrap.css({ top: $pullDown.outerHeight(), transition: "top .3s" });
        $pullDown.attr("data-loading", "true");
        pullDownState.isLoading = true;
        const r = await loading;
        console.log(`data is ${r}, now the list should snap back`);
        pullDownState.isLoading = false;
        pullDownState.shouldLoadAfterRelease = false;
        $productListWrap
          .css("top", 0)
          .one("transitionend", () => {
            $pullDown.attr("data-loading", "false");
            $productListWrap.css("transition", "");
          });
      }],
      [
        Draggable.makeClampY(0, 200),
        Draggable.moveOnlyY,
        pos => {
          if (pos.y > 100) {
            pullDownState.shouldLoadAfterRelease = true;
          }
        },
      ],
    );
  </script>
</body>
</html>
